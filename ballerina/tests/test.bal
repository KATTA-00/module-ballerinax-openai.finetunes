// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/test;
import ballerina/io;

configurable boolean isLiveServer = ?;
configurable string token = ?;
configurable string serviceUrl = isLiveServer ? "https://api.openai.com/v1" : "http://localhost:9090";
final ConnectionConfig config = {auth: {token}};

final Client baseClient = check new Client(config, serviceUrl);
final string fileName = "sample.jsonl";

// Models

@test:Config {}
isolated function testListModels() returns error? {

    ListModelsResponse|error modelsResponse = check baseClient->/models.get();

    if (modelsResponse is ListModelsResponse) {
        test:assertEquals(modelsResponse.'object, "list", "Object type mismatched");
        test:assertTrue(modelsResponse.hasKey("data"), "Response does not have the key 'data'");
    } else {
        return modelsResponse;
    }
}

@test:Config {
    dependsOn: [testListModels]
}
isolated function testRetrieveModel() returns error? {

    ListModelsResponse|error modelsResponse = check baseClient->/models.get();

    string modelId = "gpt-3.5-turbo";

    if (modelsResponse is ListModelsResponse) {
        modelId = modelsResponse.data[0].id;
    } else {
        return modelsResponse;
    }

    Model|error modelResponse = baseClient->/models/[modelId].get();

    if (modelResponse is Model) {
        test:assertEquals(modelResponse.id, modelId, "Model id mismatched");
        test:assertTrue(modelResponse.hasKey("object"), "Response does not have the key 'object'");
    } else {
        return modelResponse;
    }

}

// @test:Config {
//     dependsOn: [testCreateFineTuningJob, testListModels]
// }
// isolated function testDeleteModel() returns error? {

//     byte[]|error fileContent = io:fileReadBytes(fileName);

//     if (fileContent is error) {
//         return fileContent;
//     }

//     CreateFileRequest fileRequest = {
//         file: {fileContent, fileName},
//         purpose: "fine-tune"
//     };

//     OpenAIFile|error fileResponse = baseClient->/files.post(fileRequest);

//     if (fileResponse is error) {
//         return fileResponse;
//     }

//     string fileId = fileResponse.id;

//     ListModelsResponse|error modelsResponse = baseClient->/models.get();

//     if (modelsResponse is error) {
//         return modelsResponse;
//     }

//     // string modelId = modelsResponse.data[0].id;
//     string modelId = "gpt-3.5-turbo";

//     CreateFineTuningJobRequest fineTuneRequest = {
//         model: modelId,
//         training_file: fileId
//     };

//     FineTuningJob|error fineTuneResponse = baseClient->/fine_tuning/jobs.post(fineTuneRequest);

//     if (fineTuneResponse is error) {
//         return fineTuneResponse;
//     }

//     string modelIdCreated = fineTuneResponse.model;

//     DeleteModelResponse|error modelResponseDelete = baseClient->/models/[modelIdCreated].delete();

//     if (modelResponseDelete is DeleteModelResponse) {
//         test:assertEquals(modelResponseDelete.id, modelIdCreated, "Model id mismatched");
//         test:assertTrue(modelResponseDelete.hasKey("object"), "Response does not have the key 'object'");
//     } else {
//         return modelResponseDelete;
//     }
// }

// // Files

@test:Config {}
isolated function testListFiles() returns error? {

    ListFilesResponse|error filesResponse = baseClient->/files.get();

    if (filesResponse is ListFilesResponse) {
        test:assertEquals(filesResponse.'object, "list", "Object type mismatched");
        test:assertTrue(filesResponse.hasKey("data"), "Response does not have the key 'data'");
    } else {
        return filesResponse;
    }

}

@test:Config {
    dependsOn: [testListFiles]
}
isolated function testCreateFile() returns error? {

    byte[]|error fileContent = io:fileReadBytes(fileName);

    if (fileContent is error) {
        return fileContent;
    }

    CreateFileRequest fileRequest = {
        file: {fileContent, fileName},
        purpose: "fine-tune"
    };

    OpenAIFile|error fileResponse = baseClient->/files.post(fileRequest);

    if (fileResponse is error) {
        return fileResponse;
    }

    test:assertEquals(fileResponse.purpose, "fine-tune", "Purpose mismatched");
    test:assertTrue(fileResponse.id !is "", "File id is empty");
}

@test:Config {
    // dependsOn: [testCreateFile]
}
isolated function testRetrieveFile() returns error? {

    ListFilesResponse|error filesResponse = baseClient->/files.get();

    if (filesResponse is ListFilesResponse) {

        string fileId = filesResponse.data[0].id;

        OpenAIFile|error fileResponse = baseClient->/files/[fileId].get();

        if (fileResponse is OpenAIFile) {
            test:assertEquals(fileResponse.id, fileId, "File id mismatched");
            test:assertTrue(fileResponse.hasKey("object"), "Response does not have the key 'object'");
        } else {
            return fileResponse;
        }
    } else {
        return filesResponse;
    }
}

@test:Config {
    dependsOn: [testCreateFile, testRetrieveFile, testListFiles]
}
isolated function testDownloadFile() returns error? {

    byte[]|error fileContent = io:fileReadBytes(fileName);

    if (fileContent is error) {
        return fileContent;
    }

    CreateFileRequest fileRequest = {
        file: {fileContent, fileName},
        purpose: "fine-tune"
    };

    OpenAIFile|error fileResponse = baseClient->/files.post(fileRequest);

    if (fileResponse is error) {
        return fileResponse;
    }

    string fileId = fileResponse.id;

    byte[]|error fileContentDownload = baseClient->/files/[fileId]/content.get();

    if (fileContentDownload is error) {
        return fileContentDownload;
    }
}

// @test:Config {
//     dependsOn: [testCreateFile, testRetrieveFile, testListFiles]
// }
// isolated function testDeleteFile() returns error? {
    
//         byte[]|error fileContent = io:fileReadBytes(fileName);
    
//         if (fileContent is error) {
//             return fileContent;
//         }
    
//         CreateFileRequest fileRequest = {
//             file: {fileContent, fileName},
//             purpose: "fine-tune"
//         };
    
//         OpenAIFile|error fileResponse = baseClient->/files.post(fileRequest);
    
//         if (fileResponse is error) {
//             return fileResponse;
//         }
    
//         string fileId = fileResponse.id;
    
//         DeleteFileResponse|error fileResponseDelete = baseClient->/files/[fileId].delete();

//         if (fileResponseDelete is DeleteFileResponse) {
//             test:assertEquals(fileResponseDelete.id, fileId, "File id mismatched");
//             test:assertTrue(fileResponseDelete.hasKey("object"), "Response does not have the key 'object'");
//         } else {
//             return fileResponseDelete;
//         }
// }

// // Fine Tuning Jobs

@test:Config {}
isolated function testListPaginatedFineTuningJobs() returns error? {

    ListPaginatedFineTuningJobsResponse|error jobsResponse = baseClient->/fine_tuning/jobs.get();

    if (jobsResponse is ListPaginatedFineTuningJobsResponse) {
        test:assertEquals(jobsResponse.'object, "list", "Object type mismatched");
        test:assertTrue(jobsResponse.hasKey("data"), "Response does not have the key 'data'");
    } else {
        return jobsResponse;
    }
}

@test:Config {
    dependsOn: [testListPaginatedFineTuningJobs, testListModels, testCreateFile, testRetrieveFile, testListFiles]
}
isolated function testCreateFineTuningJob() returns error? {

    byte[]|error fileContent = io:fileReadBytes(fileName);

    if (fileContent is error) {
        return fileContent;
    }

    CreateFileRequest fileRequest = {
        file: {fileContent, fileName},
        purpose: "fine-tune"
    };

    OpenAIFile|error fileResponse = baseClient->/files.post(fileRequest);

    if (fileResponse is error) {
        return fileResponse;
    }

    string fileId = fileResponse.id;

    ListModelsResponse|error modelsResponse = baseClient->/models.get();

    if (modelsResponse is error) {
        return modelsResponse;
    }

    // string modelId = modelsResponse.data[0].id;
    string modelId = "gpt-3.5-turbo";

    CreateFineTuningJobRequest fineTuneRequest = {
        model: modelId,
        training_file: fileId
    };

    FineTuningJob|error fineTuneResponse = baseClient->/fine_tuning/jobs.post(fineTuneRequest);
        
    if (fineTuneResponse is FineTuningJob) {
        test:assertTrue(fineTuneResponse.hasKey("object"), "Response does not have the key 'object'");
        test:assertTrue(fineTuneResponse.hasKey("id"), "Response does not have the key 'id'");
    } else {
        return fineTuneResponse;
    }

}

@test:Config {
    dependsOn: [testCreateFineTuningJob]
}
isolated function testRetrieveFineTuningJob() returns error? {

    ListPaginatedFineTuningJobsResponse|error jobsResponse = baseClient->/fine_tuning/jobs.get();

    if (jobsResponse is ListPaginatedFineTuningJobsResponse) {
        string jobId = jobsResponse.data[0].id;

        FineTuningJob|error jobResponse = baseClient->/fine_tuning/jobs/[jobId].get();

        if (jobResponse is FineTuningJob) {
            test:assertEquals(jobResponse.id, jobId, "Job id mismatched");
            test:assertTrue(jobResponse.hasKey("object"), "Response does not have the key 'object'");
        } else {
            return jobResponse;
        }
    } else {
        return jobsResponse;
    }

}

@test:Config {
    dependsOn: [testCreateFineTuningJob]
}
isolated function testListFineTuningEvents() returns error? {

    string fine_tuning_job_id = "ftjob-qxrbfm03AOBVju8HYytXc0lN";

    ListPaginatedFineTuningJobsResponse|error jobsResponse = baseClient->/fine_tuning/jobs.get();

    if (jobsResponse is ListPaginatedFineTuningJobsResponse) {
        fine_tuning_job_id = jobsResponse.data[0].id;
    } else {
        return jobsResponse;
    }

    ListFineTuningJobEventsResponse|error eventsResponse = baseClient->/fine_tuning/jobs/[fine_tuning_job_id]/events.get();

    if (eventsResponse is ListFineTuningJobEventsResponse) {
        test:assertEquals(eventsResponse.'object, "list", "Object type mismatched");
        test:assertTrue(eventsResponse.hasKey("data"), "Response does not have the key 'data'");
    } else {
        return eventsResponse;
    }

}

@test:Config {
    dependsOn: [testCreateFineTuningJob]
}
isolated function testListFineTuningJobCheckpoints() returns error? {

    string fine_tuning_job_id = "ftjob-qxrbfm03AOBVju8HYytXc0lN";

    ListPaginatedFineTuningJobsResponse|error jobsResponse = baseClient->/fine_tuning/jobs.get();

    if (jobsResponse is ListPaginatedFineTuningJobsResponse) {
        fine_tuning_job_id = jobsResponse.data[0].id;
    } else {
        return jobsResponse;
    }

    ListFineTuningJobCheckpointsResponse|error checkpointsResponse = baseClient->/fine_tuning/jobs/[fine_tuning_job_id]/checkpoints.get();

    if (checkpointsResponse is ListFineTuningJobCheckpointsResponse) {
        test:assertEquals(checkpointsResponse.'object, "list", "Object type mismatched");
        test:assertTrue(checkpointsResponse.hasKey("data"), "Response does not have the key 'data'");
    } else {
        return checkpointsResponse;
    }

}

// @test:Config {
//     dependsOn: [testCreateFineTuningJob]
// }
// isolated function testCancelFineTuningJob() returns error? {

//     string fine_tuning_job_id = "ftjob-qxrbfm03AOBVju8HYytXc0lN";

//     ListPaginatedFineTuningJobsResponse|error jobsResponse = baseClient->/fine_tuning/jobs.get();

//     if (jobsResponse is ListPaginatedFineTuningJobsResponse) {
//         fine_tuning_job_id = jobsResponse.data[0].id;
//     } else {
//         return jobsResponse;
//     }

//     FineTuningJob|error jobResponse = baseClient->/fine_tuning/jobs/[fine_tuning_job_id]/cancel.post();

//     if (jobResponse is FineTuningJob) {
//         test:assertEquals(jobResponse.id, fine_tuning_job_id, "Job id mismatched");
//         test:assertTrue(jobResponse.hasKey("object"), "Response does not have the key 'object'");
//     } else {
//         return jobResponse;
//     }
// }